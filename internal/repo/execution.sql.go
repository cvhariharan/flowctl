// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: execution.sql

package repo

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
)

const addToQueue = `-- name: AddToQueue :one
INSERT INTO execution_queue (
    flow_id,
    input
) VALUES (
    $1, $2
) RETURNING id, uuid, flow_id, input, status, created_at
`

type AddToQueueParams struct {
	FlowID int32           `db:"flow_id" json:"flow_id"`
	Input  json.RawMessage `db:"input" json:"input"`
}

func (q *Queries) AddToQueue(ctx context.Context, arg AddToQueueParams) (ExecutionQueue, error) {
	row := q.db.QueryRowContext(ctx, addToQueue, arg.FlowID, arg.Input)
	var i ExecutionQueue
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.FlowID,
		&i.Input,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const dequeue = `-- name: Dequeue :many
UPDATE execution_queue SET status = 'running' WHERE id IN (
    SELECT id FROM execution_queue WHERE status = 'pending' ORDER BY created_at LIMIT $1 FOR UPDATE SKIP LOCKED
) RETURNING uuid, flow_id, input
`

type DequeueRow struct {
	Uuid   uuid.UUID       `db:"uuid" json:"uuid"`
	FlowID int32           `db:"flow_id" json:"flow_id"`
	Input  json.RawMessage `db:"input" json:"input"`
}

func (q *Queries) Dequeue(ctx context.Context, limit int32) ([]DequeueRow, error) {
	rows, err := q.db.QueryContext(ctx, dequeue, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DequeueRow
	for rows.Next() {
		var i DequeueRow
		if err := rows.Scan(&i.Uuid, &i.FlowID, &i.Input); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dequeueByID = `-- name: DequeueByID :one
UPDATE execution_queue SET status = 'running' WHERE id = (
    SELECT id FROM execution_queue WHERE status = 'pending' AND execution_queue.id = $1 FOR UPDATE SKIP LOCKED
) RETURNING uuid, flow_id, input
`

type DequeueByIDRow struct {
	Uuid   uuid.UUID       `db:"uuid" json:"uuid"`
	FlowID int32           `db:"flow_id" json:"flow_id"`
	Input  json.RawMessage `db:"input" json:"input"`
}

func (q *Queries) DequeueByID(ctx context.Context, id int32) (DequeueByIDRow, error) {
	row := q.db.QueryRowContext(ctx, dequeueByID, id)
	var i DequeueByIDRow
	err := row.Scan(&i.Uuid, &i.FlowID, &i.Input)
	return i, err
}

const getFromQueueByID = `-- name: GetFromQueueByID :one
SELECT id, uuid, flow_id, input, status, created_at FROM execution_queue WHERE id = $1
`

func (q *Queries) GetFromQueueByID(ctx context.Context, id int32) (ExecutionQueue, error) {
	row := q.db.QueryRowContext(ctx, getFromQueueByID, id)
	var i ExecutionQueue
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.FlowID,
		&i.Input,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const updateStatusByID = `-- name: UpdateStatusByID :exec
UPDATE execution_queue SET status = $2 WHERE id = $1
`

type UpdateStatusByIDParams struct {
	ID     int32           `db:"id" json:"id"`
	Status ExecutionStatus `db:"status" json:"status"`
}

func (q *Queries) UpdateStatusByID(ctx context.Context, arg UpdateStatusByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateStatusByID, arg.ID, arg.Status)
	return err
}
