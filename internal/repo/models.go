// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package repo

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

type ExecutionStatus string

const (
	ExecutionStatusPending    ExecutionStatus = "pending"
	ExecutionStatusRunning    ExecutionStatus = "running"
	ExecutionStatusSuccessful ExecutionStatus = "successful"
	ExecutionStatusFailed     ExecutionStatus = "failed"
)

func (e *ExecutionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ExecutionStatus(s)
	case string:
		*e = ExecutionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ExecutionStatus: %T", src)
	}
	return nil
}

type NullExecutionStatus struct {
	ExecutionStatus ExecutionStatus `json:"execution_status"`
	Valid           bool            `json:"valid"` // Valid is true if ExecutionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullExecutionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ExecutionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ExecutionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullExecutionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ExecutionStatus), nil
}

type UserLoginType string

const (
	UserLoginTypeOidc     UserLoginType = "oidc"
	UserLoginTypeStandard UserLoginType = "standard"
	UserLoginTypeToken    UserLoginType = "token"
)

func (e *UserLoginType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserLoginType(s)
	case string:
		*e = UserLoginType(s)
	default:
		return fmt.Errorf("unsupported scan type for UserLoginType: %T", src)
	}
	return nil
}

type NullUserLoginType struct {
	UserLoginType UserLoginType `json:"user_login_type"`
	Valid         bool          `json:"valid"` // Valid is true if UserLoginType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserLoginType) Scan(value interface{}) error {
	if value == nil {
		ns.UserLoginType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserLoginType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserLoginType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserLoginType), nil
}

type UserRoleType string

const (
	UserRoleTypeAdmin UserRoleType = "admin"
	UserRoleTypeUser  UserRoleType = "user"
)

func (e *UserRoleType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRoleType(s)
	case string:
		*e = UserRoleType(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRoleType: %T", src)
	}
	return nil
}

type NullUserRoleType struct {
	UserRoleType UserRoleType `json:"user_role_type"`
	Valid        bool         `json:"valid"` // Valid is true if UserRoleType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRoleType) Scan(value interface{}) error {
	if value == nil {
		ns.UserRoleType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRoleType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRoleType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRoleType), nil
}

type ExecutionQueue struct {
	ID        int32           `db:"id" json:"id"`
	Uuid      uuid.UUID       `db:"uuid" json:"uuid"`
	FlowID    int32           `db:"flow_id" json:"flow_id"`
	Input     json.RawMessage `db:"input" json:"input"`
	Status    ExecutionStatus `db:"status" json:"status"`
	CreatedAt time.Time       `db:"created_at" json:"created_at"`
}

type Flow struct {
	ID          int32          `db:"id" json:"id"`
	Slug        string         `db:"slug" json:"slug"`
	Name        string         `db:"name" json:"name"`
	Description sql.NullString `db:"description" json:"description"`
	CreatedAt   time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time      `db:"updated_at" json:"updated_at"`
}

type Result struct {
	ID          int32                 `db:"id" json:"id"`
	Uuid        uuid.UUID             `db:"uuid" json:"uuid"`
	FlowID      int32                 `db:"flow_id" json:"flow_id"`
	ExecutionID int32                 `db:"execution_id" json:"execution_id"`
	Output      json.RawMessage       `db:"output" json:"output"`
	Error       pqtype.NullRawMessage `db:"error" json:"error"`
	CreatedAt   time.Time             `db:"created_at" json:"created_at"`
}

type User struct {
	ID        int32          `db:"id" json:"id"`
	Uuid      uuid.UUID      `db:"uuid" json:"uuid"`
	Username  string         `db:"username" json:"username"`
	Password  sql.NullString `db:"password" json:"password"`
	LoginType UserLoginType  `db:"login_type" json:"login_type"`
	Role      UserRoleType   `db:"role" json:"role"`
	CreatedAt time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt time.Time      `db:"updated_at" json:"updated_at"`
}
