---
title: Executor System
description: Understanding flowctl's executor architecture
---

import { Aside } from '@astrojs/starlight/components';

## Overview

Executors define how flow actions run. Flowctl provides a pluggable executor system where new execution environments can be added without modifying core code.

## Architecture

```
┌─────────────┐
│ Flow Engine │
└──────┬──────┘
       │
       ▼
┌────────────────┐
│   Executor     │
│   Registry     │
└───────┬────────┘
        │
    ┌───┴────┐
    ▼        ▼
┌────────┐ ┌────────┐
│ Docker │ │ Script │
└────────┘ └────────┘
```

## Executor Interface

All executors implement this interface:

```go
type Executor interface {
    // Execute the action and return output variables
    Execute(ctx context.Context, execCtx ExecutionContext) (map[string]string, error)

    // Upload a file before execution
    PushFile(ctx context.Context, localFilePath, remoteFilePath string) error

    // Download a file after execution (artifacts)
    PullFile(ctx context.Context, remoteFilePath, localFilePath string) error

    // Close and cleanup resources
    Close() error
}
```

## Execution Context

Actions receive this context during execution:

```go
type ExecutionContext struct {
    // YAML config from the 'with' field
    WithConfig []byte

    // Files to preserve after execution
    Artifacts []string

    // Variables from the action definition
    Inputs map[string]interface{}

    // Output streams
    Stdout io.Writer
    Stderr io.Writer
}
```

## Built-in Executors

### Docker Executor

Runs scripts in Docker containers.

**Location:** `/app/executors/docker/executor.go`

**Configuration:**
```yaml
executor: docker
with:
  image: docker.io/node:18
  script: |
    npm install
    npm test
```

**Features:**
- Isolated execution environment
- Any Docker image
- Automatic container cleanup
- Artifact transfer
- Works on remote nodes

**Output File:**
- Available as `$OUTPUT` environment variable
- Path: `/tmp/flow/output`
- Format: `KEY=value` pairs

### Script Executor

Runs shell scripts directly on the host.

**Location:** `/app/executors/script/executor.go`

**Configuration:**
```yaml
executor: script
with:
  script: |
    echo "Running on $(hostname)"
    systemctl restart myapp
  interpreter: /bin/bash  # optional, defaults to /bin/bash
```

**Features:**
- Direct host execution
- Custom interpreter
- System access
- Works on remote nodes

**Output File:**
- Available as `$OUTPUT` environment variable
- Path: `/tmp/script-executor-output-{id}`
- Format: `KEY=value` pairs

## Registration

Executors register themselves at initialization:

```go
func init() {
    executor.RegisterExecutor("docker", NewDockerExecutor)
    executor.RegisterSchema("docker", GetSchema())
}
```

**Registry functions:**
- `RegisterExecutor(name, factory)` - Register executor factory
- `RegisterSchema(name, schema)` - Register JSON schema for UI
- `GetNewExecutorFunc(name)` - Retrieve executor factory
- `GetSchema(name)` - Retrieve schema for validation

## Executor Lifecycle

### 1. Creation

Flow engine creates executor with node info:

```go
factory, _ := executor.GetNewExecutorFunc("docker")
exec, err := factory("action-name", node)
```

### 2. File Upload (Optional)

Push files before execution:

```go
err := exec.PushFile(ctx, "/local/config.yaml", "/config.yaml")
```

### 3. Execution

Run the action:

```go
outputs, err := exec.Execute(ctx, ExecutionContext{
    WithConfig: yamlConfig,
    Artifacts:  []string{"/tmp/report.txt"},
    Inputs:     map[string]interface{}{"version": "1.0"},
    Stdout:     os.Stdout,
    Stderr:     os.Stderr,
})
```

### 4. Artifact Retrieval

Download preserved files:

```go
err := exec.PullFile(ctx, "/tmp/report.txt", "/local/report.txt")
```

### 5. Cleanup

Close and release resources:

```go
defer exec.Close()
```

## Docker Executor Details

### Container Lifecycle

1. Pull image from registry
2. Create container with script
3. Mount output file
4. Copy artifacts to container (push)
5. Start container
6. Stream logs
7. Wait for completion
8. Copy artifacts from container (pull)
9. Remove container

### Working Directory

All operations happen in `/` inside the container.

### Artifacts

**Push directory:** `/push` - Files copied to container before execution

**Pull directory:** `/pull` - Files copied from container after execution

**Artifact paths:** Files mounted at their declared paths (e.g., `/tmp/file.txt`)

### Remote Execution

For remote nodes:
- Creates SSH tunnel to Docker socket
- Uses remote Docker daemon
- Transfers artifacts via remote client

## Script Executor Details

### Execution

**Local:**
```go
cmd := exec.CommandContext(ctx, interpreter, "-c", script)
cmd.Env = variables
cmd.Run()
```

**Remote:**
```go
// Build script with shebang and exports
scriptContent := buildRemoteScript(config, env)

// Upload and execute
client.Upload(ctx, localScript, remoteScript)
client.RunCommand(ctx, remoteScript, stdout, stderr)
```

### Environment Variables

All inputs are available as environment variables:

```yaml
variables:
  - version: "{{ input.version }}"
  - env: "{{ input.environment }}"
```

Becomes:
```bash
export version=1.0
export env=production
```

## Output Variables

Both executors support output variables via `$OUTPUT` file:

**Writing outputs:**
```bash
echo "BUILD_ID=12345" >> $OUTPUT
echo "STATUS=success" >> $OUTPUT
```

**Accessing in flows:**
```yaml
outputs:
  - build_id: "{{ actions.my_action.output.BUILD_ID }}"
  - status: "{{ actions.my_action.output.STATUS }}"
```

## JSON Schema

Executors provide JSON schemas for UI validation:

```go
type DockerWithConfig struct {
    Image  string `json:"image" jsonschema:"title=image,description=Docker Image"`
    Script string `json:"script" jsonschema:"title=script" jsonschema_extras:"widget=codeeditor"`
}

func GetSchema() interface{} {
    return jsonschema.Reflect(&DockerWithConfig{})
}
```

This enables:
- UI form generation
- Input validation
- Auto-completion
- Documentation

## Adding a Custom Executor

### 1. Create Package

Create `/app/executors/myexecutor/executor.go`:

```go
package myexecutor

import (
    "context"
    "github.com/cvhariharan/flowctl/sdk/executor"
)

type myExecutor struct {
    name         string
    remoteClient remoteclient.RemoteClient
}

func init() {
    executor.RegisterExecutor("myexecutor", NewMyExecutor)
    executor.RegisterSchema("myexecutor", GetSchema())
}

func NewMyExecutor(name string, node executor.Node) (executor.Executor, error) {
    exec := &myExecutor{name: name}

    // Initialize remote client if needed
    if node.Hostname != "" {
        clientType := node.ConnectionType
        if clientType == "" {
            clientType = "ssh"
        }
        client, err := remoteclient.GetClient(clientType, node)
        if err != nil {
            return nil, err
        }
        exec.remoteClient = client
    }

    return exec, nil
}

func (e *myExecutor) Execute(ctx context.Context, execCtx executor.ExecutionContext) (map[string]string, error) {
    // Parse config
    var config MyConfig
    yaml.Unmarshal(execCtx.WithConfig, &config)

    // Execute
    // ...

    // Return outputs
    return map[string]string{"result": "success"}, nil
}

func (e *myExecutor) PushFile(ctx context.Context, localPath, remotePath string) error {
    // Handle file upload
    return nil
}

func (e *myExecutor) PullFile(ctx context.Context, remotePath, localPath string) error {
    // Handle file download
    return nil
}

func (e *myExecutor) Close() error {
    if e.remoteClient != nil {
        return e.remoteClient.Close()
    }
    return nil
}
```

### 2. Define Schema

```go
type MyConfig struct {
    Command string `json:"command" jsonschema:"title=Command"`
    Args    string `json:"args" jsonschema:"title=Arguments"`
}

func GetSchema() interface{} {
    return jsonschema.Reflect(&MyConfig{})
}
```

### 3. Import in Main

```go
import _ "github.com/cvhariharan/flowctl/executors/myexecutor"
```

### 4. Use in Flows

```yaml
- id: my_action
  executor: myexecutor
  with:
    command: mycommand
    args: --verbose
```

## Best Practices

### Context Handling

Respect context cancellation:

```go
select {
case <-ctx.Done():
    cleanup()
    return nil, ctx.Err()
case result := <-resultCh:
    return result, nil
}
```

### Error Messages

Include action name in errors:

```go
return nil, fmt.Errorf("action '%s' failed: %w", e.name, err)
```

### Resource Cleanup

Use defer and proper Close():

```go
func (e *myExecutor) Close() error {
    var errs []error
    if e.remoteClient != nil {
        if err := e.remoteClient.Close(); err != nil {
            errs = append(errs, err)
        }
    }
    // Clean up other resources
    return errors.Join(errs...)
}
```

### Remote Execution

Adapt behavior based on remote client:

```go
if e.remoteClient == nil {
    // Local execution
    return e.executeLocal(ctx, config)
} else {
    // Remote execution
    return e.executeRemote(ctx, config)
}
```

### Artifact Handling

Create directories as needed:

```go
dir := filepath.Dir(localPath)
if err := os.MkdirAll(dir, 0755); err != nil {
    return err
}
```

## Configuration Schema

### Schema Tags

```go
type Config struct {
    // Title shown in UI
    Image string `jsonschema:"title=Docker Image"`

    // With description
    Script string `jsonschema:"title=Script,description=Shell script to execute"`

    // Custom widget
    Code string `jsonschema_extras:"widget=codeeditor"`

    // Required field
    Required string `jsonschema:"required"`

    // With default
    Optional string `jsonschema:"default=value"`
}
```

### Validation

Schema enables automatic validation:
- Required fields
- Type checking
- Format validation
- Custom constraints

## Troubleshooting

### "executor 'X' is not registered"

Executor package not imported in main.

### Outputs not appearing

- Verify `$OUTPUT` file is written correctly
- Use `KEY=value` format
- Check file is created at correct path

### Remote execution fails

- Verify remote client is initialized
- Check node connectivity
- Ensure Docker/dependencies installed on remote

### Context cancellation issues

- Check for blocking operations
- Add context checks in loops
- Clean up goroutines properly

### Artifact transfer fails

- Verify paths are absolute
- Check filesystem permissions
- Ensure sufficient disk space
- Verify artifact paths exist

## Resources

- **Interface:** `/app/sdk/executor/executor.go`
- **Registry:** `/app/sdk/executor/registry.go`
- **Docker Executor:** `/app/executors/docker/executor.go`
- **Script Executor:** `/app/executors/script/executor.go`
- **Remote Client:** [Remote Client documentation](/advanced/remote-client)
