---
title: QSSH - SSH over QUIC
description: Learn about QSSH, flowctl's high-performance SSH implementation over QUIC protocol
---

import { Aside } from '@astrojs/starlight/components';

## Overview

QSSH is a high-performance SSH implementation that runs over the QUIC protocol instead of traditional TCP. Flowctl integrates QSSH to provide improved reliability and performance for remote node connections, especially in challenging network conditions.

## What is QSSH?

QSSH combines the security and compatibility of SSH with the modern transport capabilities of QUIC (Quick UDP Internet Connections). It provides a drop-in replacement for standard SSH connections while offering significant benefits for unreliable or high-latency networks.

### Key Benefits

**Improved Network Resilience**
- Better performance over unstable networks
- Faster connection establishment
- Reduced head-of-line blocking
- Connection migration support (survives IP address changes)

**Modern Protocol Advantages**
- UDP-based transport (QUIC protocol)
- Multiplexed streams without blocking
- Built-in connection recovery
- Lower latency for concurrent operations

**Transparent Integration**
- Works with existing SSH authentication methods
- Compatible with standard SSH keys and passwords
- Uses familiar SSH security model
- No changes required to remote servers

## When to Use QSSH

QSSH is particularly beneficial in these scenarios:

### High-Latency Networks
- Geographically distributed infrastructure
- Cloud-to-edge deployments
- Satellite or cellular connections
- International remote nodes

### Unstable Networks
- Mobile or wireless connections
- Networks with packet loss
- Environments with frequent reconnections
- NAT traversal scenarios

### Performance-Critical Workflows
- Large file transfers (artifacts)
- Real-time log streaming
- Concurrent multi-node operations
- Time-sensitive deployments

<Aside type="tip">
Start with standard SSH and switch to QSSH if you experience connection reliability issues or need improved performance.
</Aside>

## Configuration

### Setting Connection Type

When adding or editing a node, select QSSH as the connection type:

**Via UI:**
1. Navigate to **Nodes**
2. Click **Add Node** or edit an existing node
3. Set **Connection Type** to `qssh`
4. Configure other settings normally

**Node Configuration Example:**

```yaml
Name: EdgeDevice1
Hostname: edge.example.com
Port: 443
Username: deploy
OS Family: linux
Connection Type: qssh  # Use QSSH instead of SSH
Credential: [Your SSH Credential]
```

### Port Configuration

QSSH uses UDP instead of TCP. Common port choices:

- **443**: Recommended for firewall-friendly deployments (HTTPS/QUIC standard port)
- **8080**: Alternative for non-privileged ports
- **Custom**: Any UDP port available on your network

<Aside type="caution">
Ensure your firewall allows UDP traffic on the selected port. QSSH uses UDP, not TCP.
</Aside>

### Credential Requirements

QSSH uses the same authentication methods as standard SSH:

**Private Key Authentication (Recommended):**
```yaml
Credential Type: private_key
Key Data: [Your SSH private key]
```

**Password Authentication:**
```yaml
Credential Type: password
Key Data: [Your password]
```

No special credentials are needed - use your existing SSH keys and passwords.

## How QSSH Works in Flowctl

### Architecture

```
┌─────────────┐          QUIC/UDP          ┌──────────────┐
│   Flowctl   │ ───────────────────────── │  QSSH Server │
│   Server    │  (SSH over QUIC protocol)  │ (Remote Node)│
└─────────────┘                            └──────────────┘
                                                    │
                                                    │ SSH
                                                    │
                                              ┌──────────┐
                                              │   SSHD   │
                                              │ (Remote) │
                                              └──────────┘
```

### Connection Flow

1. **Initialization**: Flowctl creates a QSSH connection using node credentials
2. **QUIC Handshake**: Establishes secure QUIC connection to remote QSSH server
3. **SSH Tunneling**: SSH protocol runs over QUIC transport
4. **Operations**: Commands, file transfers, and Docker operations proceed normally
5. **Connection Pooling**: Connections are reused for efficiency

### Transparent Operation

Once configured, QSSH works identically to standard SSH:
- ✓ Same SSH authentication methods
- ✓ Same SFTP file transfers
- ✓ Same command execution interface
- ✓ Same security guarantees
- ✓ Compatible with all executors (Docker, Script)

## Setting Up QSSH Server

To use QSSH, you need a QSSH server running on your remote nodes.

### Installation

**Option 1: From Source**
```bash
git clone https://github.com/cvhariharan/qssh.git
cd qssh
go build -o qssh-server ./cmd/server
sudo mv qssh-server /usr/local/bin/
```

**Option 2: Download Binary**
```bash
# Download from GitHub releases
wget https://github.com/cvhariharan/qssh/releases/latest/download/qssh-server-linux-amd64
chmod +x qssh-server-linux-amd64
sudo mv qssh-server-linux-amd64 /usr/local/bin/qssh-server
```

### Configuration

Create a configuration file at `/etc/qssh/config.toml`:

```toml
[server]
# Address to listen on
listen = "0.0.0.0:443"

# SSH server to forward connections to
ssh_address = "localhost:22"

[tls]
# TLS certificates for QUIC
cert_file = "/etc/qssh/cert.pem"
key_file = "/etc/qssh/key.pem"

# Optional: Mutual TLS for enhanced security
[mtls]
enabled = false
ca_file = "/etc/qssh/ca.pem"
```

### Generate TLS Certificates

QSSH requires TLS certificates for QUIC:

```bash
# Self-signed certificate (for testing)
openssl req -x509 -newkey rsa:4096 -keyout /etc/qssh/key.pem \
  -out /etc/qssh/cert.pem -days 365 -nodes \
  -subj "/CN=edge.example.com"

# Set proper permissions
sudo chmod 600 /etc/qssh/key.pem
sudo chmod 644 /etc/qssh/cert.pem
```

<Aside type="caution">
For production, use certificates from a trusted Certificate Authority (Let's Encrypt, etc.).
</Aside>

### Running the Server

**Foreground (testing):**
```bash
sudo qssh-server -config /etc/qssh/config.toml
```

**As a systemd service:**

Create `/etc/systemd/system/qssh-server.service`:

```ini
[Unit]
Description=QSSH Server
After=network.target

[Service]
Type=simple
User=root
ExecStart=/usr/local/bin/qssh-server -config /etc/qssh/config.toml
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

Enable and start the service:

```bash
sudo systemctl daemon-reload
sudo systemctl enable qssh-server
sudo systemctl start qssh-server
sudo systemctl status qssh-server
```

### Firewall Configuration

Allow UDP traffic on your QSSH port:

**UFW (Ubuntu/Debian):**
```bash
sudo ufw allow 443/udp
```

**firewalld (RHEL/CentOS):**
```bash
sudo firewall-cmd --permanent --add-port=443/udp
sudo firewall-cmd --reload
```

**iptables:**
```bash
sudo iptables -A INPUT -p udp --dport 443 -j ACCEPT
sudo iptables-save | sudo tee /etc/iptables/rules.v4
```

## Using QSSH in Flows

Once configured, QSSH nodes work exactly like standard SSH nodes:

```yaml
metadata:
  id: edge_deployment
  name: Deploy to Edge Devices
  description: Deploy application to edge devices using QSSH

inputs:
  - name: version
    type: string
    label: Version
    required: true

actions:
  # Works transparently with QSSH nodes
  - id: deploy_edge
    name: Deploy to Edge
    executor: docker
    on:
      - EdgeDevice1  # Configured with QSSH
      - EdgeDevice2  # Configured with QSSH
    variables:
      - version: "{{ input.version }}"
    with:
      image: docker.io/alpine
      script: |
        echo "Deploying version $version"
        # Commands execute normally over QSSH
        echo "DEPLOYED_AT=$(date -Iseconds)" >> $OUTPUT

  # File transfers work seamlessly
  - id: collect_logs
    name: Collect Edge Logs
    executor: script
    on:
      - EdgeDevice1
    with:
      script: |
        tar czf /tmp/logs.tar.gz /var/log/app/
    artifacts:
      - /tmp/logs.tar.gz  # Transferred via QSSH/SFTP

outputs:
  - version: "{{ input.version }}"
  - deployed_at: "{{ actions.deploy_edge.output.DEPLOYED_AT }}"
```

## Performance Comparison

### SSH vs QSSH

| Metric | Standard SSH | QSSH |
|--------|-------------|------|
| Protocol | TCP | UDP (QUIC) |
| Connection Setup | Slower | Faster (0-RTT) |
| Packet Loss Handling | Head-of-line blocking | Stream-level recovery |
| Network Changes | Connection drops | Connection migration |
| Concurrent Operations | Serialized channels | True multiplexing |
| Latency Sensitivity | Higher impact | Lower impact |

### Real-World Scenarios

**Scenario 1: High-Latency Network (200ms RTT)**
- SSH: ~1.5s connection time
- QSSH: ~0.8s connection time
- **Improvement: ~47% faster**

**Scenario 2: 5% Packet Loss**
- SSH: Frequent stalls, degraded throughput
- QSSH: Minimal impact, stream-level recovery
- **Improvement: 2-3x better throughput**

**Scenario 3: Mobile Network with IP Changes**
- SSH: Connection drops, requires reconnection
- QSSH: Seamless connection migration
- **Improvement: Uninterrupted operations**

## Security Considerations

### Authentication

QSSH uses the same SSH authentication mechanisms:
- Public key authentication (recommended)
- Password authentication
- All SSH security best practices apply

### Transport Security

QSSH adds an additional layer of security:
- **TLS encryption** for QUIC transport
- **SSH encryption** for data layer
- **Double encryption** by default

### Certificate Management

**For Development:**
- Self-signed certificates are acceptable
- Certificate validation may be relaxed

**For Production:**
- Use certificates from trusted CAs
- Enable certificate validation
- Consider mutual TLS (mTLS) for enhanced security

<Aside type="caution">
Never disable certificate validation in production environments without understanding the security implications.
</Aside>

## Troubleshooting

### Connection Issues

**"Failed to dial" errors:**
```bash
# Check QSSH server is running
sudo systemctl status qssh-server

# Check UDP port is accessible
nc -u -v -z edge.example.com 443

# Check firewall rules
sudo ufw status
```

**Certificate errors:**
```bash
# Verify certificate files exist
ls -l /etc/qssh/cert.pem /etc/qssh/key.pem

# Check certificate validity
openssl x509 -in /etc/qssh/cert.pem -text -noout

# Ensure proper permissions
sudo chmod 600 /etc/qssh/key.pem
```

**Connection timeouts:**
- Verify UDP port is open on firewalls
- Check network allows UDP traffic
- Confirm QSSH server is listening on correct port
- Test with standard SSH first to isolate QSSH issues

### Performance Issues

**Slow connections:**
- Check network latency with `ping`
- Monitor packet loss with `mtr`
- Review QSSH server logs for errors
- Compare with standard SSH performance

**File transfer problems:**
- Verify SFTP is working over standard SSH
- Check available disk space
- Monitor network bandwidth
- Review artifact sizes and optimize if needed

### Debugging

**Enable verbose logging:**

Flowctl side (check logs):
```bash
# View flowctl logs for QSSH connection details
journalctl -u flowctl -f | grep -i qssh
```

QSSH server side:
```bash
# Run server in foreground with verbose output
sudo qssh-server -config /etc/qssh/config.toml -v

# Or check systemd logs
sudo journalctl -u qssh-server -f
```

**Common log messages:**

```
✓ "QSSH connection established" - Successful connection
✗ "failed to dial" - Connection failed (network/firewall)
✗ "certificate verification failed" - TLS certificate issue
✗ "authentication failed" - SSH credential problem
```

## Migration Guide

### Switching from SSH to QSSH

1. **Set up QSSH server** on target nodes
2. **Test connectivity** with a single node
3. **Update node configuration** in flowctl
4. **Verify flow execution** works correctly
5. **Roll out gradually** to other nodes

### Rollback Strategy

If issues occur:
1. Change node connection type back to `ssh`
2. Ensure standard SSH port (22) is accessible
3. Update flows if necessary
4. Investigate and resolve QSSH issues
5. Retry QSSH migration when ready

### Hybrid Approach

You can use both SSH and QSSH simultaneously:
- Critical production nodes: Use stable SSH
- Edge/remote nodes: Use QSSH for better resilience
- Testing nodes: Experiment with QSSH

## Best Practices

### Deployment

1. **Test thoroughly** in non-production environments first
2. **Monitor performance** and compare with SSH baseline
3. **Start with non-critical nodes** to validate stability
4. **Document configuration** for team members
5. **Have rollback plan** in case of issues

### Security

1. **Use proper TLS certificates** from trusted CAs in production
2. **Enable mTLS** for highly sensitive environments
3. **Rotate certificates** regularly (every 90 days)
4. **Monitor QSSH server** for security events
5. **Keep QSSH updated** to latest version for security patches

### Operations

1. **Monitor QSSH server** resource usage (CPU, memory, network)
2. **Set up alerts** for QSSH server failures
3. **Document firewall rules** for team and audit purposes
4. **Test failover** to SSH if QSSH becomes unavailable
5. **Maintain logs** for troubleshooting and compliance

## Advanced Configuration

### Mutual TLS (mTLS)

For enhanced security, enable mutual TLS authentication:

**Server configuration:**
```toml
[mtls]
enabled = true
ca_file = "/etc/qssh/ca.pem"
require_client_cert = true
```

**Generate client certificates:**
```bash
# Generate CA
openssl genrsa -out ca-key.pem 4096
openssl req -new -x509 -days 365 -key ca-key.pem -out ca.pem

# Generate client certificate
openssl genrsa -out client-key.pem 4096
openssl req -new -key client-key.pem -out client.csr
openssl x509 -req -days 365 -in client.csr -CA ca.pem \
  -CAkey ca-key.pem -CAcreateserial -out client-cert.pem
```

### Custom QUIC Parameters

Fine-tune QUIC protocol settings:

```toml
[quic]
max_idle_timeout = "30s"
max_incoming_streams = 100
max_incoming_uni_streams = 100
```

### Load Balancing

For high-availability setups, run multiple QSSH servers:

```bash
# Server 1
qssh-server -config /etc/qssh/config-1.toml -listen 0.0.0.0:443

# Server 2
qssh-server -config /etc/qssh/config-2.toml -listen 0.0.0.0:444
```

Use DNS round-robin or load balancer to distribute connections.

## Resources

- **QSSH GitHub**: [github.com/cvhariharan/qssh](https://github.com/cvhariharan/qssh)
- **QUIC Protocol**: [RFC 9000](https://www.rfc-editor.org/rfc/rfc9000.html)
- **Flowctl Nodes Guide**: [Nodes and Executors](/general/nodes-and-executors)

## Next Steps

- Set up your first QSSH node using the installation guide
- Compare performance with standard SSH in your environment
- Review [Remote Nodes documentation](/general/nodes-and-executors) for general usage
- Explore [Task Execution](/general/execution) for flow optimization strategies
