---
title: Task Execution
description: Learn how flowctl executes tasks and schedules workflows
---

import { Aside } from "@astrojs/starlight/components";

## Overview

Flowctl executes workflows both locally and on remote nodes. The scheduler manages task queuing, execution, and status tracking to ensure reliable workflow processing.

## Task Lifecycle

Every task goes through these states:

- **Pending** - Task is queued, waiting to be executed
- **Running** - Task is currently executing
- **Pending Approval** - Task paused, waiting for manual approval
- **Completed** - Task finished successfully
- **Errored** - Task failed with an error
- **Cancelled** - Task was cancelled by user

## Trigger Types

### Manual Execution

Users trigger flows manually through the UI. This is useful for:

- On-demand operations
- Testing workflows
- User-initiated tasks
- Flows that require dynamic input

All flows support manual execution by default. Users provide input values through the UI when triggering the flow.

### Scheduled Execution

Flows can run automatically on a schedule using cron expressions:

```yaml
metadata:
  id: daily_backup
  name: Daily Database Backup
  schedules:
    - "0 2 * * *" # Daily at 2 AM
    - "0 14 * * 0" # Weekly on Sunday at 2 PM

inputs:
  - name: retention_days
    type: int
    default: 7 # Required for scheduled flows

  - name: environment
    type: string
    default: "production"
```

<Aside type="caution">
  Scheduled flows must have default values for all inputs, since they run
  without user interaction.
</Aside>

#### Cron Expression Format

Flowctl uses standard cron syntax:

```
┌───────────── minute (0 - 59)
│ ┌───────────── hour (0 - 23)
│ │ ┌───────────── day of month (1 - 31)
│ │ │ ┌───────────── month (1 - 12)
│ │ │ │ ┌───────────── day of week (0 - 6) (Sunday to Saturday)
│ │ │ │ │
* * * * *
```

<Aside>
  Schedule changes may take up to 5 minutes to take effect. The scheduler
  periodically syncs schedules from the database.
</Aside>

## Execution Contexts

### Local Execution

Actions without the `on` field run on the flowctl server:

```yaml
- id: local_task
  name: Run Locally
  executor: docker
  with:
    image: alpine
    script: |
      echo "Running on flowctl server"
```

### Remote Execution

Actions with the `on` field run on specified nodes:

```yaml
- id: remote_task
  name: Run on Remote Nodes
  executor: script
  on:
    - WebServer1
    - WebServer2
  with:
    script: |
      hostname
      echo "Running on remote node"
```

Remote execution requires SSH connectivity to the target nodes. Configure nodes in the Nodes section of the UI.

### Parallel vs Sequential Execution

Within a flow:

- **Actions** execute sequentially (one after another)
- **Nodes** within an action execute in parallel

```yaml
actions:
  # Action 1 runs first
  - id: first
    name: First Action
    executor: docker
    with:
      image: alpine
      script: echo "I run first"

  # Action 2 runs after Action 1 completes
  - id: second
    name: Second Action
    executor: script
    on:
      - Node1 # These three run in parallel
      - Node2
      - Node3
    with:
      script: echo "We run in parallel on different nodes"
```

## Worker Configuration

The scheduler uses a worker pool to execute tasks concurrently. Configure the number of workers in `config.toml`:

```toml
[app.scheduler]
  workers = 20  # Number of concurrent tasks
```

The default value is equal to the number of cores.

## Scheduling Configuration

Configure how often the scheduler checks for new scheduled flows:

```toml
[app.scheduler]
  cron_sync_interval = "5m0s"  # Check for schedule changes every 5 minutes
```

## Artifact Sharing

Actions can share files using artifacts:

```yaml
- id: create_file
  name: Create File
  executor: docker
  with:
    image: alpine
    script: echo "data" > /tmp/file.txt
  artifacts:
    - /tmp/file.txt # File is preserved

- id: use_file
  name: Use File
  executor: docker
  with:
    image: alpine
    script: cat /tmp/file.txt # File is available from previous action
```

**Remote Node Artifacts:**

When running on remote nodes, artifacts are automatically transferred:

```yaml
- id: create_on_remote
  name: Create on Remote
  executor: docker
  on:
    - RemoteNode
  with:
    image: alpine
    script: echo "Hello" > /tmp/message.txt
  artifacts:
    - /tmp/message.txt

- id: use_locally
  name: Use Locally
  executor: docker
  with:
    image: alpine
    script: |
      # Access artifact from RemoteNode at /RemoteNode/tmp/message.txt
      cat /RemoteNode/tmp/message.txt
```

## Approval Workflow

Actions marked with `approval: true` pause execution and wait for manual approval:

```yaml
- id: deploy_prod
  name: Deploy to Production
  executor: script
  approval: true # Requires approval
  on:
    - ProductionServer
  with:
    script: ./deploy.sh
```

**Approval Process:**

1. Flow executes up to the approval action
2. Execution status changes to "Pending Approval"
3. Approver reviews and approves/rejects via UI
4. If approved, execution continues
5. If rejected, execution fails

## Cancelling Executions

Cancel running or pending tasks from the execution history page:

1. Navigate to the execution in History
2. Click the Cancel button
3. The execution stops and status changes to "Cancelled"

Cancellation propagates to all running actions and remote nodes.
